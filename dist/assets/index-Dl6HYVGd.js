import{di as w,co as u,dG as Se,d1 as He,aI as x,dH as pe,dI as be,aB as Ae}from"./index-CwMm_7HW.js";function Ce(i,e){for(var t=0;t<e.length;t++){const o=e[t];if(typeof o!="string"&&!Array.isArray(o)){for(const s in o)if(s!=="default"&&!(s in i)){const n=Object.getOwnPropertyDescriptor(o,s);n&&Object.defineProperty(i,s,n.get?n:{enumerable:!0,get:()=>o[s]})}}}return Object.freeze(Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}))}var ve={},q={},G={},we={},ee={};const Le="goerli",Oe=5,_e=5,Fe="merge",De={type:"poa",algorithm:"clique",clique:{period:15,epoch:3e4}},Re="Cross-client PoA test network",Ge="https://github.com/goerli/testnet",Me={timestamp:"0x5c51a607",gasLimit:10485760,difficulty:1,nonce:"0x0000000000000000",extraData:"0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},Ne=[{name:"chainstart",block:0,forkHash:"0xa3f5ab08"},{name:"homestead",block:0,forkHash:"0xa3f5ab08"},{name:"tangerineWhistle",block:0,forkHash:"0xa3f5ab08"},{name:"spuriousDragon",block:0,forkHash:"0xa3f5ab08"},{name:"byzantium",block:0,forkHash:"0xa3f5ab08"},{name:"constantinople",block:0,forkHash:"0xa3f5ab08"},{name:"petersburg",block:0,forkHash:"0xa3f5ab08"},{name:"istanbul",block:1561651,forkHash:"0xc25efa5c"},{name:"berlin",block:4460644,forkHash:"0x757a1c47"},{name:"london",block:5062605,forkHash:"0xb8c6299d"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",name:"merge",ttd:"10790000",block:7382819,forkHash:"0xb8c6299d"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,timestamp:"1678832736",forkHash:"0xf9843abf"}],qe=[{ip:"51.141.78.53",port:30303,id:"011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a",location:"",comment:"Upstream bootnode 1"},{ip:"13.93.54.137",port:30303,id:"176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b",location:"",comment:"Upstream bootnode 2"},{ip:"94.237.54.114",port:30313,id:"46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291",location:"",comment:"Upstream bootnode 3"},{ip:"18.218.250.66",port:30313,id:"b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949",location:"",comment:"Upstream bootnode 4"},{ip:"3.11.147.67",port:30303,id:"a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91",location:"",comment:"Ethereum Foundation bootnode"},{ip:"51.15.116.226",port:30303,id:"a869b02cec167211fb4815a82941db2e7ed2936fd90e78619c53eb17753fcf0207463e3419c264e2a1dd8786de0df7e68cf99571ab8aeb7c4e51367ef186b1dd",location:"",comment:"Goerli Initiative bootnode"},{ip:"51.15.119.157",port:30303,id:"807b37ee4816ecf407e9112224494b74dd5933625f655962d892f2f0f02d7fbbb3e2a94cf87a96609526f30c998fd71e93e2f53015c558ffc8b03eceaf30ee33",location:"",comment:"Goerli Initiative bootnode"},{ip:"51.15.119.157",port:40303,id:"a59e33ccd2b3e52d578f1fbd70c6f9babda2650f0760d6ff3b37742fdcdfdb3defba5d56d315b40c46b70198c7621e63ffa3f987389c7118634b0fefbbdfa7fd",location:"",comment:"Goerli Initiative bootnode"}],ze=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"],Ue={name:Le,chainId:Oe,networkId:_e,defaultHardfork:Fe,consensus:De,comment:Re,url:Ge,genesis:Me,hardforks:Ne,bootstrapNodes:qe,dnsNetworks:ze},je="mainnet",Ke=1,Ve=1,Je="merge",Ye={type:"pow",algorithm:"ethash",ethash:{}},We="The Ethereum main chain",Xe="https://ethstats.net/",Ze={gasLimit:5e3,difficulty:17179869184,nonce:"0x0000000000000042",extraData:"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"},Qe=[{name:"chainstart",block:0,forkHash:"0xfc64ec04"},{name:"homestead",block:115e4,forkHash:"0x97c2c34c"},{name:"dao",block:192e4,forkHash:"0x91d1f948"},{name:"tangerineWhistle",block:2463e3,forkHash:"0x7a64da13"},{name:"spuriousDragon",block:2675e3,forkHash:"0x3edd5b10"},{name:"byzantium",block:437e4,forkHash:"0xa00bc324"},{name:"constantinople",block:728e4,forkHash:"0x668db0af"},{name:"petersburg",block:728e4,forkHash:"0x668db0af"},{name:"istanbul",block:9069e3,forkHash:"0x879d6e30"},{name:"muirGlacier",block:92e5,forkHash:"0xe029e991"},{name:"berlin",block:12244e3,forkHash:"0x0eb440f6"},{name:"london",block:12965e3,forkHash:"0xb715077d"},{name:"arrowGlacier",block:13773e3,forkHash:"0x20c327fc"},{name:"grayGlacier",block:1505e4,forkHash:"0xf0afd0e3"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",name:"merge",ttd:"58750000000000000000000",block:15537394,forkHash:"0xf0afd0e3"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,timestamp:"1681338455",forkHash:"0xdce96c2d"}],et=[{ip:"18.138.108.67",port:30303,id:"d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666",location:"ap-southeast-1-001",comment:"bootnode-aws-ap-southeast-1-001"},{ip:"3.209.45.79",port:30303,id:"22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de",location:"us-east-1-001",comment:"bootnode-aws-us-east-1-001"},{ip:"65.108.70.101",port:30303,id:"2b252ab6a1d0f971d9722cb839a42cb81db019ba44c08754628ab4a823487071b5695317c8ccd085219c3a03af063495b2f1da8d18218da2d6a82981b45e6ffc",location:"eu-west-1-001",comment:"bootnode-hetzner-hel"},{ip:"157.90.35.166",port:30303,id:"4aeb4ab6c14b23e2c4cfdce879c04b0748a20d8e9b59e25ded2a08143e265c6c25936e74cbc8e641e3312ca288673d91f2f93f8e277de3cfa444ecdaaf982052",location:"eu-central-1-001",comment:"bootnode-hetzner-fsn"}],tt=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"],ot={name:je,chainId:Ke,networkId:Ve,defaultHardfork:Je,consensus:Ye,comment:We,url:Xe,genesis:Ze,hardforks:Qe,bootstrapNodes:et,dnsNetworks:tt},st="rinkeby",nt=4,rt=4,at="london",it={type:"poa",algorithm:"clique",clique:{period:15,epoch:3e4}},ct="PoA test network",dt="https://www.rinkeby.io",ft={timestamp:"0x58ee40ba",gasLimit:47e5,difficulty:1,nonce:"0x0000000000000000",extraData:"0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},ut=[{name:"chainstart",block:0,forkHash:"0x3b8e0691"},{name:"homestead",block:1,forkHash:"0x60949295"},{name:"tangerineWhistle",block:2,forkHash:"0x8bde40dd"},{name:"spuriousDragon",block:3,forkHash:"0xcb3a64bb"},{name:"byzantium",block:1035301,forkHash:"0x8d748b57"},{name:"constantinople",block:3660663,forkHash:"0xe49cab14"},{name:"petersburg",block:4321234,forkHash:"0xafec6b27"},{name:"istanbul",block:5435345,forkHash:"0xcbdb8838"},{name:"berlin",block:8290928,forkHash:"0x6910c8bd"},{name:"london",block:8897988,forkHash:"0x8e29f2f3"},{name:"merge",block:null,forkHash:null},{name:"shanghai",block:null,forkHash:null}],mt=[{ip:"52.169.42.101",port:30303,id:"a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf",location:"",comment:"IE"},{ip:"52.3.158.184",port:30303,id:"343149e4feefa15d882d9fe4ac7d88f885bd05ebb735e547f12e12080a9fa07c8014ca6fd7f373123488102fe5e34111f8509cf0b7de3f5b44339c9f25e87cb8",location:"",comment:"INFURA"},{ip:"159.89.28.211",port:30303,id:"b6b28890b006743680c52e64e0d16db57f28124885595fa03a562be1d2bf0f3a1da297d56b13da25fb992888fd556d4c1a27b1f39d531bde7de1921c90061cc6",location:"",comment:"AKASHA"}],ht=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.rinkeby.ethdisco.net"],lt={name:st,chainId:nt,networkId:rt,defaultHardfork:at,consensus:it,comment:ct,url:dt,genesis:ft,hardforks:ut,bootstrapNodes:mt,dnsNetworks:ht},gt="ropsten",pt=3,bt=3,vt="merge",$t={type:"pow",algorithm:"ethash",ethash:{}},kt="PoW test network",Pt="https://github.com/ethereum/ropsten",It={gasLimit:16777216,difficulty:1048576,nonce:"0x0000000000000042",extraData:"0x3535353535353535353535353535353535353535353535353535353535353535"},Et=[{name:"chainstart",block:0,forkHash:"0x30c7ddbc"},{name:"homestead",block:0,forkHash:"0x30c7ddbc"},{name:"tangerineWhistle",block:0,forkHash:"0x30c7ddbc"},{name:"spuriousDragon",block:10,forkHash:"0x63760190"},{name:"byzantium",block:17e5,forkHash:"0x3ea159c7"},{name:"constantinople",block:423e4,forkHash:"0x97b544f3"},{name:"petersburg",block:4939394,forkHash:"0xd6e2149b"},{name:"istanbul",block:6485846,forkHash:"0x4bc66396"},{name:"muirGlacier",block:7117117,forkHash:"0x6727ef90"},{name:"berlin",block:9812189,forkHash:"0xa157d377"},{name:"london",block:10499401,forkHash:"0x7119b6b3"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge",name:"merge",ttd:"50000000000000000",block:null,forkHash:"0x7119b6b3"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,forkHash:null}],Tt=[{ip:"52.176.7.10",port:30303,id:"30b7ab30a01c124a6cceca36863ece12c4f5fa68e3ba9b0b51407ccc002eeed3b3102d20a88f1c1d3c3154e2449317b8ef95090e77b312d5cc39354f86d5d606",location:"",comment:"US-Azure geth"},{ip:"52.176.100.77",port:30303,id:"865a63255b3bb68023b6bffd5095118fcc13e79dcf014fe4e47e065c350c7cc72af2e53eff895f11ba1bbb6a2b33271c1116ee870f266618eadfc2e78aa7349c",location:"",comment:"US-Azure parity"},{ip:"52.232.243.152",port:30303,id:"6332792c4a00e3e4ee0926ed89e0d27ef985424d97b6a45bf0f23e51f0dcb5e66b875777506458aea7af6f9e4ffb69f43f3778ee73c81ed9d34c51c4b16b0b0f",location:"",comment:"Parity"},{ip:"192.81.208.223",port:30303,id:"94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f09",location:"",comment:"@gpip"}],yt=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.ropsten.ethdisco.net"],wt={name:gt,chainId:pt,networkId:bt,defaultHardfork:vt,consensus:$t,comment:kt,url:Pt,genesis:It,hardforks:Et,bootstrapNodes:Tt,dnsNetworks:yt},Bt="sepolia",xt=11155111,St=11155111,Ht="merge",At={type:"pow",algorithm:"ethash",ethash:{}},Ct="PoW test network to replace Ropsten",Lt="https://github.com/ethereum/go-ethereum/pull/23730",Ot={timestamp:"0x6159af19",gasLimit:3e7,difficulty:131072,nonce:"0x0000000000000000",extraData:"0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"},_t=[{name:"chainstart",block:0,forkHash:"0xfe3366e7"},{name:"homestead",block:0,forkHash:"0xfe3366e7"},{name:"tangerineWhistle",block:0,forkHash:"0xfe3366e7"},{name:"spuriousDragon",block:0,forkHash:"0xfe3366e7"},{name:"byzantium",block:0,forkHash:"0xfe3366e7"},{name:"constantinople",block:0,forkHash:"0xfe3366e7"},{name:"petersburg",block:0,forkHash:"0xfe3366e7"},{name:"istanbul",block:0,forkHash:"0xfe3366e7"},{name:"muirGlacier",block:0,forkHash:"0xfe3366e7"},{name:"berlin",block:0,forkHash:"0xfe3366e7"},{name:"london",block:0,forkHash:"0xfe3366e7"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",name:"merge",ttd:"17000000000000000",block:1450409,forkHash:"0xfe3366e7"},{name:"mergeForkIdTransition",block:1735371,forkHash:"0xb96cbd13"},{name:"shanghai",block:null,timestamp:"1677557088",forkHash:"0xf7f9bc08"}],Ft=[{ip:"18.168.182.86",port:30303,id:"9246d00bc8fd1742e5ad2428b80fc4dc45d786283e05ef6edbd9002cbc335d40998444732fbe921cb88e1d2c73d1b1de53bae6a2237996e9bfe14f871baf7066",location:"",comment:"geth"},{ip:"52.14.151.177",port:30303,id:"ec66ddcf1a974950bd4c782789a7e04f8aa7110a72569b6e65fcd51e937e74eed303b1ea734e4d19cfaec9fbff9b6ee65bf31dcb50ba79acce9dd63a6aca61c7",location:"",comment:"besu"},{ip:"165.22.196.173",port:30303,id:"ce970ad2e9daa9e14593de84a8b49da3d54ccfdf83cbc4fe519cb8b36b5918ed4eab087dedd4a62479b8d50756b492d5f762367c8d20329a7854ec01547568a6",location:"",comment:"EF"},{ip:"65.108.95.67",port:30303,id:"075503b13ed736244896efcde2a992ec0b451357d46cb7a8132c0384721742597fc8f0d91bbb40bb52e7d6e66728d36a1fda09176294e4a30cfac55dcce26bc6",location:"",comment:"lodestar"}],Dt=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"],Rt={name:Bt,chainId:xt,networkId:St,defaultHardfork:Ht,consensus:At,comment:Ct,url:Lt,genesis:Ot,hardforks:_t,bootstrapNodes:Ft,dnsNetworks:Dt};var te={};const Gt="EIP-1153",Mt=1153,Nt="Transient Storage",qt="https://eips.ethereum.org/EIPS/eip-1153",zt="Review",Ut="chainstart",jt=[],Kt={},Vt={tstore:{v:100,d:"Base fee of the TSTORE opcode"},tload:{v:100,d:"Base fee of the TLOAD opcode"}},Jt={},Yt={},Wt={name:Gt,number:Mt,comment:Nt,url:qt,status:zt,minimumHardfork:Ut,requiredEIPs:jt,gasConfig:Kt,gasPrices:Vt,vm:Jt,pow:Yt},Xt="EIP-1559",Zt=1559,Qt="Fee market change for ETH 1.0 chain",eo="https://eips.ethereum.org/EIPS/eip-1559",to="Final",oo="berlin",so=[2930],no={baseFeeMaxChangeDenominator:{v:8,d:"Maximum base fee change denominator"},elasticityMultiplier:{v:2,d:"Maximum block gas target elasticity"},initialBaseFee:{v:1e9,d:"Initial base fee on first EIP1559 block"}},ro={},ao={},io={},co={name:Xt,number:Zt,comment:Qt,url:eo,status:to,minimumHardfork:oo,requiredEIPs:so,gasConfig:no,gasPrices:ro,vm:ao,pow:io},fo="EIP-2315",uo=2315,mo="Simple subroutines for the EVM",ho="https://eips.ethereum.org/EIPS/eip-2315",lo="Draft",go="istanbul",po={},bo={beginsub:{v:2,d:"Base fee of the BEGINSUB opcode"},returnsub:{v:5,d:"Base fee of the RETURNSUB opcode"},jumpsub:{v:10,d:"Base fee of the JUMPSUB opcode"}},vo={},$o={},ko={name:fo,number:uo,comment:mo,url:ho,status:lo,minimumHardfork:go,gasConfig:po,gasPrices:bo,vm:vo,pow:$o},Po="EIP-2537",Io=2537,Eo="BLS12-381 precompiles",To="https://eips.ethereum.org/EIPS/eip-2537",yo="Draft",wo="chainstart",Bo={},xo={Bls12381G1AddGas:{v:600,d:"Gas cost of a single BLS12-381 G1 addition precompile-call"},Bls12381G1MulGas:{v:12e3,d:"Gas cost of a single BLS12-381 G1 multiplication precompile-call"},Bls12381G2AddGas:{v:4500,d:"Gas cost of a single BLS12-381 G2 addition precompile-call"},Bls12381G2MulGas:{v:55e3,d:"Gas cost of a single BLS12-381 G2 multiplication precompile-call"},Bls12381PairingBaseGas:{v:115e3,d:"Base gas cost of BLS12-381 pairing check"},Bls12381PairingPerPairGas:{v:23e3,d:"Per-pair gas cost of BLS12-381 pairing check"},Bls12381MapG1Gas:{v:5500,d:"Gas cost of BLS12-381 map field element to G1"},Bls12381MapG2Gas:{v:11e4,d:"Gas cost of BLS12-381 map field element to G2"},Bls12381MultiExpGasDiscount:{v:[[1,1200],[2,888],[3,764],[4,641],[5,594],[6,547],[7,500],[8,453],[9,438],[10,423],[11,408],[12,394],[13,379],[14,364],[15,349],[16,334],[17,330],[18,326],[19,322],[20,318],[21,314],[22,310],[23,306],[24,302],[25,298],[26,294],[27,289],[28,285],[29,281],[30,277],[31,273],[32,269],[33,268],[34,266],[35,265],[36,263],[37,262],[38,260],[39,259],[40,257],[41,256],[42,254],[43,253],[44,251],[45,250],[46,248],[47,247],[48,245],[49,244],[50,242],[51,241],[52,239],[53,238],[54,236],[55,235],[56,233],[57,232],[58,231],[59,229],[60,228],[61,226],[62,225],[63,223],[64,222],[65,221],[66,220],[67,219],[68,219],[69,218],[70,217],[71,216],[72,216],[73,215],[74,214],[75,213],[76,213],[77,212],[78,211],[79,211],[80,210],[81,209],[82,208],[83,208],[84,207],[85,206],[86,205],[87,205],[88,204],[89,203],[90,202],[91,202],[92,201],[93,200],[94,199],[95,199],[96,198],[97,197],[98,196],[99,196],[100,195],[101,194],[102,193],[103,193],[104,192],[105,191],[106,191],[107,190],[108,189],[109,188],[110,188],[111,187],[112,186],[113,185],[114,185],[115,184],[116,183],[117,182],[118,182],[119,181],[120,180],[121,179],[122,179],[123,178],[124,177],[125,176],[126,176],[127,175],[128,174]],d:"Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"}},So={},Ho={},Ao={name:Po,number:Io,comment:Eo,url:To,status:yo,minimumHardfork:wo,gasConfig:Bo,gasPrices:xo,vm:So,pow:Ho},Co="EIP-2565",Lo=2565,Oo="ModExp gas cost",_o="https://eips.ethereum.org/EIPS/eip-2565",Fo="Final",Do="byzantium",Ro={},Go={modexpGquaddivisor:{v:3,d:"Gquaddivisor from modexp precompile for gas calculation"}},Mo={},No={},qo={name:Co,number:Lo,comment:Oo,url:_o,status:Fo,minimumHardfork:Do,gasConfig:Ro,gasPrices:Go,vm:Mo,pow:No},zo="EIP-2718",Uo="Typed Transaction Envelope",jo="https://eips.ethereum.org/EIPS/eip-2718",Ko="Final",Vo="chainstart",Jo={},Yo={},Wo={},Xo={},Zo={name:zo,comment:Uo,url:jo,status:Ko,minimumHardfork:Vo,gasConfig:Jo,gasPrices:Yo,vm:Wo,pow:Xo},Qo="EIP-2929",es="Gas cost increases for state access opcodes",ts="https://eips.ethereum.org/EIPS/eip-2929",os="Final",ss="chainstart",ns={},rs={coldsload:{v:2100,d:"Gas cost of the first read of storage from a given location (per transaction)"},coldaccountaccess:{v:2600,d:"Gas cost of the first read of a given address (per transaction)"},warmstorageread:{v:100,d:"Gas cost of reading storage locations which have already loaded 'cold'"},sstoreCleanGasEIP2200:{v:2900,d:"Once per SSTORE operation from clean non-zero to something else"},sstoreNoopGasEIP2200:{v:100,d:"Once per SSTORE operation if the value doesn't change"},sstoreDirtyGasEIP2200:{v:100,d:"Once per SSTORE operation if a dirty value is changed"},sstoreInitRefundEIP2200:{v:19900,d:"Once per SSTORE operation for resetting to the original zero value"},sstoreCleanRefundEIP2200:{v:4900,d:"Once per SSTORE operation for resetting to the original non-zero value"},call:{v:0,d:"Base fee of the CALL opcode"},callcode:{v:0,d:"Base fee of the CALLCODE opcode"},delegatecall:{v:0,d:"Base fee of the DELEGATECALL opcode"},staticcall:{v:0,d:"Base fee of the STATICCALL opcode"},balance:{v:0,d:"Base fee of the BALANCE opcode"},extcodesize:{v:0,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:0,d:"Base fee of the EXTCODECOPY opcode"},extcodehash:{v:0,d:"Base fee of the EXTCODEHASH opcode"},sload:{v:0,d:"Base fee of the SLOAD opcode"},sstore:{v:0,d:"Base fee of the SSTORE opcode"}},as={},is={},cs={name:Qo,comment:es,url:ts,status:os,minimumHardfork:ss,gasConfig:ns,gasPrices:rs,vm:as,pow:is},ds="EIP-2930",fs="Optional access lists",us="https://eips.ethereum.org/EIPS/eip-2930",ms="Final",hs="istanbul",ls=[2718,2929],gs={},ps={accessListStorageKeyCost:{v:1900,d:"Gas cost per storage key in an Access List transaction"},accessListAddressCost:{v:2400,d:"Gas cost per storage key in an Access List transaction"}},bs={},vs={},$s={name:ds,comment:fs,url:us,status:ms,minimumHardfork:hs,requiredEIPs:ls,gasConfig:gs,gasPrices:ps,vm:bs,pow:vs},ks="EIP-3074",Ps=3074,Is="AUTH and AUTHCALL opcodes",Es="https://eips.ethereum.org/EIPS/eip-3074",Ts="Review",ys="london",ws={},Bs={auth:{v:3100,d:"Gas cost of the AUTH opcode"},authcall:{v:0,d:"Gas cost of the AUTHCALL opcode"},authcallValueTransfer:{v:6700,d:"Paid for CALL when the value transfer is non-zero"}},xs={},Ss={},Hs={name:ks,number:Ps,comment:Is,url:Es,status:Ts,minimumHardfork:ys,gasConfig:ws,gasPrices:Bs,vm:xs,pow:Ss},As="EIP-3198",Cs=3198,Ls="BASEFEE opcode",Os="https://eips.ethereum.org/EIPS/eip-3198",_s="Final",Fs="london",Ds={},Rs={basefee:{v:2,d:"Gas cost of the BASEFEE opcode"}},Gs={},Ms={},Ns={name:As,number:Cs,comment:Ls,url:Os,status:_s,minimumHardfork:Fs,gasConfig:Ds,gasPrices:Rs,vm:Gs,pow:Ms},qs="EIP-3529",zs="Reduction in refunds",Us="https://eips.ethereum.org/EIPS/eip-3529",js="Final",Ks="berlin",Vs=[2929],Js={maxRefundQuotient:{v:5,d:"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},Ys={selfdestructRefund:{v:0,d:"Refunded following a selfdestruct operation"},sstoreClearRefundEIP2200:{v:4800,d:"Once per SSTORE operation for clearing an originally existing storage slot"}},Ws={},Xs={},Zs={name:qs,comment:zs,url:Us,status:js,minimumHardfork:Ks,requiredEIPs:Vs,gasConfig:Js,gasPrices:Ys,vm:Ws,pow:Xs},Qs="EIP-3540",en=3540,tn="EVM Object Format (EOF) v1",on="https://eips.ethereum.org/EIPS/eip-3540",sn="Review",nn="london",rn=[3541],an={},cn={},dn={},fn={},un={name:Qs,number:en,comment:tn,url:on,status:sn,minimumHardfork:nn,requiredEIPs:rn,gasConfig:an,gasPrices:cn,vm:dn,pow:fn},mn="EIP-3541",hn="Reject new contracts starting with the 0xEF byte",ln="https://eips.ethereum.org/EIPS/eip-3541",gn="Final",pn="berlin",bn=[],vn={},$n={},kn={},Pn={},In={name:mn,comment:hn,url:ln,status:gn,minimumHardfork:pn,requiredEIPs:bn,gasConfig:vn,gasPrices:$n,vm:kn,pow:Pn},En="EIP-3554",Tn="Reduction in refunds",yn="Difficulty Bomb Delay to December 1st 2021",wn="Final",Bn="muirGlacier",xn=[],Sn={},Hn={},An={},Cn={difficultyBombDelay:{v:95e5,d:"the amount of blocks to delay the difficulty bomb with"}},Ln={name:En,comment:Tn,url:yn,status:wn,minimumHardfork:Bn,requiredEIPs:xn,gasConfig:Sn,gasPrices:Hn,vm:An,pow:Cn},On="EIP-3607",_n=3607,Fn="Reject transactions from senders with deployed code",Dn="https://eips.ethereum.org/EIPS/eip-3607",Rn="Final",Gn="chainstart",Mn=[],Nn={},qn={},zn={},Un={},jn={name:On,number:_n,comment:Fn,url:Dn,status:Rn,minimumHardfork:Gn,requiredEIPs:Mn,gasConfig:Nn,gasPrices:qn,vm:zn,pow:Un},Kn="EIP-3651",Vn=3198,Jn="Warm COINBASE",Yn="https://eips.ethereum.org/EIPS/eip-3651",Wn="Review",Xn="london",Zn=[2929],Qn={},er={},tr={},or={},sr={name:Kn,number:Vn,comment:Jn,url:Yn,status:Wn,minimumHardfork:Xn,requiredEIPs:Zn,gasConfig:Qn,gasPrices:er,vm:tr,pow:or},nr="EIP-3670",rr=3670,ar="EOF - Code Validation",ir="https://eips.ethereum.org/EIPS/eip-3670",cr="Review",dr="london",fr=[3540],ur={},mr={},hr={},lr={},gr={name:nr,number:rr,comment:ar,url:ir,status:cr,minimumHardfork:dr,requiredEIPs:fr,gasConfig:ur,gasPrices:mr,vm:hr,pow:lr},pr="EIP-3675",br=3675,vr="Upgrade consensus to Proof-of-Stake",$r="https://eips.ethereum.org/EIPS/eip-3675",kr="Final",Pr="london",Ir=[],Er={},Tr={},yr={},wr={},Br={name:pr,number:br,comment:vr,url:$r,status:kr,minimumHardfork:Pr,requiredEIPs:Ir,gasConfig:Er,gasPrices:Tr,vm:yr,pow:wr},xr="EIP-3855",Sr=3855,Hr="PUSH0 instruction",Ar="https://eips.ethereum.org/EIPS/eip-3855",Cr="Review",Lr="chainstart",Or=[],_r={},Fr={push0:{v:2,d:"Base fee of the PUSH0 opcode"}},Dr={},Rr={},Gr={name:xr,number:Sr,comment:Hr,url:Ar,status:Cr,minimumHardfork:Lr,requiredEIPs:Or,gasConfig:_r,gasPrices:Fr,vm:Dr,pow:Rr},Mr="EIP-3860",Nr=3860,qr="Limit and meter initcode",zr="https://eips.ethereum.org/EIPS/eip-3860",Ur="Review",jr="spuriousDragon",Kr=[],Vr={},Jr={initCodeWordCost:{v:2,d:"Gas to pay for each word (32 bytes) of initcode when creating a contract"}},Yr={maxInitCodeSize:{v:49152,d:"Maximum length of initialization code when creating a contract"}},Wr={},Xr={name:Mr,number:Nr,comment:qr,url:zr,status:Ur,minimumHardfork:jr,requiredEIPs:Kr,gasConfig:Vr,gasPrices:Jr,vm:Yr,pow:Wr},Zr="EIP-4345",Qr=4345,ea="Difficulty Bomb Delay to June 2022",ta="https://eips.ethereum.org/EIPS/eip-4345",oa="Final",sa="london",na={},ra={},aa={},ia={difficultyBombDelay:{v:107e5,d:"the amount of blocks to delay the difficulty bomb with"}},ca={name:Zr,number:Qr,comment:ea,url:ta,status:oa,minimumHardfork:sa,gasConfig:na,gasPrices:ra,vm:aa,pow:ia},da="EIP-4399",fa=4399,ua="Supplant DIFFICULTY opcode with PREVRANDAO",ma="https://eips.ethereum.org/EIPS/eip-4399",ha="Review",la="london",ga=[],pa={},ba={},va={},$a={},ka={name:da,number:fa,comment:ua,url:ma,status:ha,minimumHardfork:la,requiredEIPs:ga,gasConfig:pa,gasPrices:ba,vm:va,pow:$a},Pa="EIP-4844",Ia=4844,Ea="Shard Blob Transactions",Ta="https://eips.ethereum.org/EIPS/eip-4844",ya="Draft",wa="merge",Ba=[1559,2718,2930,4895],xa={dataGasPerBlob:{v:131072,d:"The base fee for data gas per blob"},targetDataGasPerBlock:{v:262144,d:"The target data gas consumed per block"},maxDataGasPerBlock:{v:524288,d:"The max data gas allowable per block"},dataGasPriceUpdateFraction:{v:2225652,d:"The denominator used in the exponential when calculating a data gas price"}},Sa={simpleGasPerBlob:{v:12e3,d:"The basic gas fee for each blob"},minDataGasPrice:{v:1,d:"The minimum fee per data gas"},kzgPointEvaluationGasPrecompilePrice:{v:5e4,d:"The fee associated with the point evaluation precompile"},datahash:{v:3,d:"Base fee of the DATAHASH opcode"}},Ha={blobCommitmentVersionKzg:{v:1,d:"The number indicated a versioned hash is a KZG commitment"},fieldElementsPerBlob:{v:4096,d:"The number of field elements allowed per blob"}},Aa={},Ca={},La={name:Pa,number:Ia,comment:Ea,url:Ta,status:ya,minimumHardfork:wa,requiredEIPs:Ba,gasConfig:xa,gasPrices:Sa,sharding:Ha,vm:Aa,pow:Ca},Oa="EIP-4895",_a=4895,Fa="Beacon chain push withdrawals as operations",Da="https://eips.ethereum.org/EIPS/eip-4895",Ra="Review",Ga="merge",Ma=[],Na={},qa={},za={},Ua={},ja={name:Oa,number:_a,comment:Fa,url:Da,status:Ra,minimumHardfork:Ga,requiredEIPs:Ma,gasConfig:Na,gasPrices:qa,vm:za,pow:Ua},Ka="EIP-5133",Va=5133,Ja="Delaying Difficulty Bomb to mid-September 2022",Ya="https://eips.ethereum.org/EIPS/eip-5133",Wa="Draft",Xa="grayGlacier",Za={},Qa={},ei={},ti={difficultyBombDelay:{v:114e5,d:"the amount of blocks to delay the difficulty bomb with"}},oi={name:Ka,number:Va,comment:Ja,url:Ya,status:Wa,minimumHardfork:Xa,gasConfig:Za,gasPrices:Qa,vm:ei,pow:ti};Object.defineProperty(te,"__esModule",{value:!0});te.EIPs=void 0;te.EIPs={1153:Wt,1559:co,2315:ko,2537:Ao,2565:qo,2718:Zo,2929:cs,2930:$s,3074:Hs,3198:Ns,3529:Zs,3540:un,3541:In,3554:Ln,3607:jn,3651:sr,3670:gr,3675:Br,3855:Gr,3860:Xr,4345:ca,4399:ka,4844:La,4895:ja,5133:oi};var oe={};(function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.CustomChain=i.ConsensusAlgorithm=i.ConsensusType=i.Hardfork=i.Chain=void 0,function(e){e[e.Mainnet=1]="Mainnet",e[e.Ropsten=3]="Ropsten",e[e.Rinkeby=4]="Rinkeby",e[e.Goerli=5]="Goerli",e[e.Sepolia=11155111]="Sepolia"}(i.Chain||(i.Chain={})),function(e){e.Chainstart="chainstart",e.Homestead="homestead",e.Dao="dao",e.TangerineWhistle="tangerineWhistle",e.SpuriousDragon="spuriousDragon",e.Byzantium="byzantium",e.Constantinople="constantinople",e.Petersburg="petersburg",e.Istanbul="istanbul",e.MuirGlacier="muirGlacier",e.Berlin="berlin",e.London="london",e.ArrowGlacier="arrowGlacier",e.GrayGlacier="grayGlacier",e.MergeForkIdTransition="mergeForkIdTransition",e.Merge="merge",e.Shanghai="shanghai",e.ShardingForkDev="shardingFork"}(i.Hardfork||(i.Hardfork={})),function(e){e.ProofOfStake="pos",e.ProofOfWork="pow",e.ProofOfAuthority="poa"}(i.ConsensusType||(i.ConsensusType={})),function(e){e.Ethash="ethash",e.Clique="clique",e.Casper="casper"}(i.ConsensusAlgorithm||(i.ConsensusAlgorithm={})),function(e){e.PolygonMainnet="polygon-mainnet",e.PolygonMumbai="polygon-mumbai",e.ArbitrumRinkebyTestnet="arbitrum-rinkeby-testnet",e.ArbitrumOne="arbitrum-one",e.xDaiChain="x-dai-chain",e.OptimisticKovan="optimistic-kovan",e.OptimisticEthereum="optimistic-ethereum"}(i.CustomChain||(i.CustomChain={}))})(oe);var se={};const si="chainstart",ni="Start of the Ethereum main chain",ri="",ai="",ii={minGasLimit:{v:5e3,d:"Minimum the gas limit may ever be"},gasLimitBoundDivisor:{v:1024,d:"The bound divisor of the gas limit, used in update calculations"},maxRefundQuotient:{v:2,d:"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},ci={base:{v:2,d:"Gas base cost, used e.g. for ChainID opcode (Istanbul)"},tierStep:{v:[0,2,3,5,8,10,20],d:"Once per operation, for a selection of them"},exp:{v:10,d:"Base fee of the EXP opcode"},expByte:{v:10,d:"Times ceil(log256(exponent)) for the EXP instruction"},sha3:{v:30,d:"Base fee of the SHA3 opcode"},sha3Word:{v:6,d:"Once per word of the SHA3 operation's data"},sload:{v:50,d:"Base fee of the SLOAD opcode"},sstoreSet:{v:2e4,d:"Once per SSTORE operation if the zeroness changes from zero"},sstoreReset:{v:5e3,d:"Once per SSTORE operation if the zeroness does not change from zero"},sstoreRefund:{v:15e3,d:"Once per SSTORE operation if the zeroness changes to zero"},jumpdest:{v:1,d:"Base fee of the JUMPDEST opcode"},log:{v:375,d:"Base fee of the LOG opcode"},logData:{v:8,d:"Per byte in a LOG* operation's data"},logTopic:{v:375,d:"Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"},create:{v:32e3,d:"Base fee of the CREATE opcode"},call:{v:40,d:"Base fee of the CALL opcode"},callStipend:{v:2300,d:"Free gas given at beginning of call"},callValueTransfer:{v:9e3,d:"Paid for CALL when the value transfor is non-zero"},callNewAccount:{v:25e3,d:"Paid for CALL when the destination address didn't exist prior"},selfdestructRefund:{v:24e3,d:"Refunded following a selfdestruct operation"},memory:{v:3,d:"Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"},quadCoeffDiv:{v:512,d:"Divisor for the quadratic particle of the memory cost equation"},createData:{v:200,d:""},tx:{v:21e3,d:"Per transaction. NOTE: Not payable on data of calls between transactions"},txCreation:{v:32e3,d:"The cost of creating a contract via tx"},txDataZero:{v:4,d:"Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"},txDataNonZero:{v:68,d:"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},copy:{v:3,d:"Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"},ecRecover:{v:3e3,d:""},sha256:{v:60,d:""},sha256Word:{v:12,d:""},ripemd160:{v:600,d:""},ripemd160Word:{v:120,d:""},identity:{v:15,d:""},identityWord:{v:3,d:""},stop:{v:0,d:"Base fee of the STOP opcode"},add:{v:3,d:"Base fee of the ADD opcode"},mul:{v:5,d:"Base fee of the MUL opcode"},sub:{v:3,d:"Base fee of the SUB opcode"},div:{v:5,d:"Base fee of the DIV opcode"},sdiv:{v:5,d:"Base fee of the SDIV opcode"},mod:{v:5,d:"Base fee of the MOD opcode"},smod:{v:5,d:"Base fee of the SMOD opcode"},addmod:{v:8,d:"Base fee of the ADDMOD opcode"},mulmod:{v:8,d:"Base fee of the MULMOD opcode"},signextend:{v:5,d:"Base fee of the SIGNEXTEND opcode"},lt:{v:3,d:"Base fee of the LT opcode"},gt:{v:3,d:"Base fee of the GT opcode"},slt:{v:3,d:"Base fee of the SLT opcode"},sgt:{v:3,d:"Base fee of the SGT opcode"},eq:{v:3,d:"Base fee of the EQ opcode"},iszero:{v:3,d:"Base fee of the ISZERO opcode"},and:{v:3,d:"Base fee of the AND opcode"},or:{v:3,d:"Base fee of the OR opcode"},xor:{v:3,d:"Base fee of the XOR opcode"},not:{v:3,d:"Base fee of the NOT opcode"},byte:{v:3,d:"Base fee of the BYTE opcode"},address:{v:2,d:"Base fee of the ADDRESS opcode"},balance:{v:20,d:"Base fee of the BALANCE opcode"},origin:{v:2,d:"Base fee of the ORIGIN opcode"},caller:{v:2,d:"Base fee of the CALLER opcode"},callvalue:{v:2,d:"Base fee of the CALLVALUE opcode"},calldataload:{v:3,d:"Base fee of the CALLDATALOAD opcode"},calldatasize:{v:2,d:"Base fee of the CALLDATASIZE opcode"},calldatacopy:{v:3,d:"Base fee of the CALLDATACOPY opcode"},codesize:{v:2,d:"Base fee of the CODESIZE opcode"},codecopy:{v:3,d:"Base fee of the CODECOPY opcode"},gasprice:{v:2,d:"Base fee of the GASPRICE opcode"},extcodesize:{v:20,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:20,d:"Base fee of the EXTCODECOPY opcode"},blockhash:{v:20,d:"Base fee of the BLOCKHASH opcode"},coinbase:{v:2,d:"Base fee of the COINBASE opcode"},timestamp:{v:2,d:"Base fee of the TIMESTAMP opcode"},number:{v:2,d:"Base fee of the NUMBER opcode"},difficulty:{v:2,d:"Base fee of the DIFFICULTY opcode"},gaslimit:{v:2,d:"Base fee of the GASLIMIT opcode"},pop:{v:2,d:"Base fee of the POP opcode"},mload:{v:3,d:"Base fee of the MLOAD opcode"},mstore:{v:3,d:"Base fee of the MSTORE opcode"},mstore8:{v:3,d:"Base fee of the MSTORE8 opcode"},sstore:{v:0,d:"Base fee of the SSTORE opcode"},jump:{v:8,d:"Base fee of the JUMP opcode"},jumpi:{v:10,d:"Base fee of the JUMPI opcode"},pc:{v:2,d:"Base fee of the PC opcode"},msize:{v:2,d:"Base fee of the MSIZE opcode"},gas:{v:2,d:"Base fee of the GAS opcode"},push:{v:3,d:"Base fee of the PUSH opcode"},dup:{v:3,d:"Base fee of the DUP opcode"},swap:{v:3,d:"Base fee of the SWAP opcode"},callcode:{v:40,d:"Base fee of the CALLCODE opcode"},return:{v:0,d:"Base fee of the RETURN opcode"},invalid:{v:0,d:"Base fee of the INVALID opcode"},selfdestruct:{v:0,d:"Base fee of the SELFDESTRUCT opcode"}},di={stackLimit:{v:1024,d:"Maximum size of VM stack allowed"},callCreateDepth:{v:1024,d:"Maximum depth of call/create stack"},maxExtraDataSize:{v:32,d:"Maximum size extra data may be after Genesis"}},fi={minimumDifficulty:{v:131072,d:"The minimum that the difficulty may ever be"},difficultyBoundDivisor:{v:2048,d:"The bound divisor of the difficulty, used in the update calculations"},durationLimit:{v:13,d:"The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"},epochDuration:{v:3e4,d:"Duration between proof-of-work epochs"},timebombPeriod:{v:1e5,d:"Exponential difficulty timebomb period"},minerReward:{v:"5000000000000000000",d:"the amount a miner get rewarded for mining a block"},difficultyBombDelay:{v:0,d:"the amount of blocks to delay the difficulty bomb with"}},ui={name:si,comment:ni,url:ri,status:ai,gasConfig:ii,gasPrices:ci,vm:di,pow:fi},mi="homestead",hi="Homestead hardfork with protocol and network changes",li="https://eips.ethereum.org/EIPS/eip-606",gi="Final",pi={},bi={delegatecall:{v:40,d:"Base fee of the DELEGATECALL opcode"}},vi={},$i={},ki={name:mi,comment:hi,url:li,status:gi,gasConfig:pi,gasPrices:bi,vm:vi,pow:$i},Pi="dao",Ii="DAO rescue hardfork",Ei="https://eips.ethereum.org/EIPS/eip-779",Ti="Final",yi={},wi={},Bi={},xi={},Si={name:Pi,comment:Ii,url:Ei,status:Ti,gasConfig:yi,gasPrices:wi,vm:Bi,pow:xi},Hi="tangerineWhistle",Ai="Hardfork with gas cost changes for IO-heavy operations",Ci="https://eips.ethereum.org/EIPS/eip-608",Li="Final",Oi={},_i={sload:{v:200,d:"Once per SLOAD operation"},call:{v:700,d:"Once per CALL operation & message call transaction"},extcodesize:{v:700,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:700,d:"Base fee of the EXTCODECOPY opcode"},balance:{v:400,d:"Base fee of the BALANCE opcode"},delegatecall:{v:700,d:"Base fee of the DELEGATECALL opcode"},callcode:{v:700,d:"Base fee of the CALLCODE opcode"},selfdestruct:{v:5e3,d:"Base fee of the SELFDESTRUCT opcode"}},Fi={},Di={},Ri={name:Hi,comment:Ai,url:Ci,status:Li,gasConfig:Oi,gasPrices:_i,vm:Fi,pow:Di},Gi="spuriousDragon",Mi="HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",Ni="https://eips.ethereum.org/EIPS/eip-607",qi="Final",zi={},Ui={expByte:{v:50,d:"Times ceil(log256(exponent)) for the EXP instruction"}},ji={maxCodeSize:{v:24576,d:"Maximum length of contract code"}},Ki={},Vi={name:Gi,comment:Mi,url:Ni,status:qi,gasConfig:zi,gasPrices:Ui,vm:ji,pow:Ki},Ji="byzantium",Yi="Hardfork with new precompiles, instructions and other protocol changes",Wi="https://eips.ethereum.org/EIPS/eip-609",Xi="Final",Zi={},Qi={modexpGquaddivisor:{v:20,d:"Gquaddivisor from modexp precompile for gas calculation"},ecAdd:{v:500,d:"Gas costs for curve addition precompile"},ecMul:{v:4e4,d:"Gas costs for curve multiplication precompile"},ecPairing:{v:1e5,d:"Base gas costs for curve pairing precompile"},ecPairingWord:{v:8e4,d:"Gas costs regarding curve pairing precompile input length"},revert:{v:0,d:"Base fee of the REVERT opcode"},staticcall:{v:700,d:"Base fee of the STATICCALL opcode"},returndatasize:{v:2,d:"Base fee of the RETURNDATASIZE opcode"},returndatacopy:{v:3,d:"Base fee of the RETURNDATACOPY opcode"}},ec={},tc={minerReward:{v:"3000000000000000000",d:"the amount a miner get rewarded for mining a block"},difficultyBombDelay:{v:3e6,d:"the amount of blocks to delay the difficulty bomb with"}},oc={name:Ji,comment:Yi,url:Wi,status:Xi,gasConfig:Zi,gasPrices:Qi,vm:ec,pow:tc},sc="constantinople",nc="Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",rc="https://eips.ethereum.org/EIPS/eip-1013",ac="Final",ic={},cc={netSstoreNoopGas:{v:200,d:"Once per SSTORE operation if the value doesn't change"},netSstoreInitGas:{v:2e4,d:"Once per SSTORE operation from clean zero"},netSstoreCleanGas:{v:5e3,d:"Once per SSTORE operation from clean non-zero"},netSstoreDirtyGas:{v:200,d:"Once per SSTORE operation from dirty"},netSstoreClearRefund:{v:15e3,d:"Once per SSTORE operation for clearing an originally existing storage slot"},netSstoreResetRefund:{v:4800,d:"Once per SSTORE operation for resetting to the original non-zero value"},netSstoreResetClearRefund:{v:19800,d:"Once per SSTORE operation for resetting to the original zero value"},shl:{v:3,d:"Base fee of the SHL opcode"},shr:{v:3,d:"Base fee of the SHR opcode"},sar:{v:3,d:"Base fee of the SAR opcode"},extcodehash:{v:400,d:"Base fee of the EXTCODEHASH opcode"},create2:{v:32e3,d:"Base fee of the CREATE2 opcode"}},dc={},fc={minerReward:{v:"2000000000000000000",d:"The amount a miner gets rewarded for mining a block"},difficultyBombDelay:{v:5e6,d:"the amount of blocks to delay the difficulty bomb with"}},uc={name:sc,comment:nc,url:rc,status:ac,gasConfig:ic,gasPrices:cc,vm:dc,pow:fc},mc="petersburg",hc="Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",lc="https://eips.ethereum.org/EIPS/eip-1716",gc="Final",pc={},bc={netSstoreNoopGas:{v:null,d:"Removed along EIP-1283"},netSstoreInitGas:{v:null,d:"Removed along EIP-1283"},netSstoreCleanGas:{v:null,d:"Removed along EIP-1283"},netSstoreDirtyGas:{v:null,d:"Removed along EIP-1283"},netSstoreClearRefund:{v:null,d:"Removed along EIP-1283"},netSstoreResetRefund:{v:null,d:"Removed along EIP-1283"},netSstoreResetClearRefund:{v:null,d:"Removed along EIP-1283"}},vc={},$c={},kc={name:mc,comment:hc,url:lc,status:gc,gasConfig:pc,gasPrices:bc,vm:vc,pow:$c},Pc="istanbul",Ic="HF targeted for December 2019 following the Constantinople/Petersburg HF",Ec="https://eips.ethereum.org/EIPS/eip-1679",Tc="Final",yc={},wc={blake2Round:{v:1,d:"Gas cost per round for the Blake2 F precompile"},ecAdd:{v:150,d:"Gas costs for curve addition precompile"},ecMul:{v:6e3,d:"Gas costs for curve multiplication precompile"},ecPairing:{v:45e3,d:"Base gas costs for curve pairing precompile"},ecPairingWord:{v:34e3,d:"Gas costs regarding curve pairing precompile input length"},txDataNonZero:{v:16,d:"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},sstoreSentryGasEIP2200:{v:2300,d:"Minimum gas required to be present for an SSTORE call, not consumed"},sstoreNoopGasEIP2200:{v:800,d:"Once per SSTORE operation if the value doesn't change"},sstoreDirtyGasEIP2200:{v:800,d:"Once per SSTORE operation if a dirty value is changed"},sstoreInitGasEIP2200:{v:2e4,d:"Once per SSTORE operation from clean zero to non-zero"},sstoreInitRefundEIP2200:{v:19200,d:"Once per SSTORE operation for resetting to the original zero value"},sstoreCleanGasEIP2200:{v:5e3,d:"Once per SSTORE operation from clean non-zero to something else"},sstoreCleanRefundEIP2200:{v:4200,d:"Once per SSTORE operation for resetting to the original non-zero value"},sstoreClearRefundEIP2200:{v:15e3,d:"Once per SSTORE operation for clearing an originally existing storage slot"},balance:{v:700,d:"Base fee of the BALANCE opcode"},extcodehash:{v:700,d:"Base fee of the EXTCODEHASH opcode"},chainid:{v:2,d:"Base fee of the CHAINID opcode"},selfbalance:{v:5,d:"Base fee of the SELFBALANCE opcode"},sload:{v:800,d:"Base fee of the SLOAD opcode"}},Bc={},xc={},Sc={name:Pc,comment:Ic,url:Ec,status:Tc,gasConfig:yc,gasPrices:wc,vm:Bc,pow:xc},Hc="muirGlacier",Ac="HF to delay the difficulty bomb",Cc="https://eips.ethereum.org/EIPS/eip-2384",Lc="Final",Oc={},_c={},Fc={},Dc={difficultyBombDelay:{v:9e6,d:"the amount of blocks to delay the difficulty bomb with"}},Rc={name:Hc,comment:Ac,url:Cc,status:Lc,gasConfig:Oc,gasPrices:_c,vm:Fc,pow:Dc},Gc="berlin",Mc="HF targeted for July 2020 following the Muir Glacier HF",Nc="https://eips.ethereum.org/EIPS/eip-2070",qc="Final",zc=[2565,2929,2718,2930],Uc={name:Gc,comment:Mc,url:Nc,status:qc,eips:zc},jc="london",Kc="HF targeted for July 2021 following the Berlin fork",Vc="https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",Jc="Final",Yc=[1559,3198,3529,3541],Wc={name:jc,comment:Kc,url:Vc,status:Jc,eips:Yc},Xc="shanghai",Zc="Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",Qc="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",ed="Final",td=[3651,3855,3860,4895],od={name:Xc,comment:Zc,url:Qc,status:ed,eips:td},sd="arrowGlacier",nd="HF to delay the difficulty bomb",rd="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",ad="Final",id=[4345],cd={},dd={},fd={},ud={},md={name:sd,comment:nd,url:rd,status:ad,eips:id,gasConfig:cd,gasPrices:dd,vm:fd,pow:ud},hd="grayGlacier",ld="Delaying the difficulty bomb to Mid September 2022",gd="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",pd="Draft",bd=[5133],vd={},$d={},kd={},Pd={},Id={name:hd,comment:ld,url:gd,status:pd,eips:bd,gasConfig:vd,gasPrices:$d,vm:kd,pow:Pd},Ed="mergeForkIdTransition",Td="Pre-merge hardfork to fork off non-upgraded clients",yd="https://eips.ethereum.org/EIPS/eip-3675",wd="Draft",Bd=[],xd={name:Ed,comment:Td,url:yd,status:wd,eips:Bd},Sd="merge",Hd="Hardfork to upgrade the consensus mechanism to Proof-of-Stake",Ad="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",Cd="Final",Ld={type:"pos",algorithm:"casper",casper:{}},Od=[3675,4399],_d={name:Sd,comment:Hd,url:Ad,status:Cd,consensus:Ld,eips:Od},Fd="shardingFork",Dd="Internal hardfork to test proto-danksharding (do not use in production)",Rd="https://eips.ethereum.org/EIPS/eip-4844",Gd="Experimental",Md=[4844],Nd={name:Fd,comment:Dd,url:Rd,status:Gd,eips:Md};Object.defineProperty(se,"__esModule",{value:!0});se.hardforks=void 0;se.hardforks={chainstart:ui,homestead:ki,dao:Si,tangerineWhistle:Ri,spuriousDragon:Vi,byzantium:oc,constantinople:uc,petersburg:kc,istanbul:Sc,muirGlacier:Rc,berlin:Uc,london:Wc,shanghai:od,arrowGlacier:md,grayGlacier:Id,mergeForkIdTransition:xd,merge:_d,shardingFork:Nd};var z={};Object.defineProperty(z,"__esModule",{value:!0});z.parseGethGenesis=void 0;const Z=w,P=oe;function qd(i){return!i||i==="0x0"?"0x0000000000000000":(0,Z.isHexPrefixed)(i)?"0x"+(0,Z.stripHexPrefix)(i).padStart(16,"0"):"0x"+i.padStart(16,"0")}function zd(i,e=!0){const{name:t,config:o,difficulty:s,mixHash:n,gasLimit:a,coinbase:r,baseFeePerGas:c}=i;let{extraData:f,timestamp:d,nonce:h}=i;const $=Number(d),{chainId:I}=o;if(f===""&&(f="0x"),(0,Z.isHexPrefixed)(d)||(d=(0,Z.intToHex)(parseInt(d))),h.length!==18&&(h=qd(h)),o.eip155Block!==o.eip158Block)throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");const k={name:t,chainId:I,networkId:I,genesis:{timestamp:d,gasLimit:parseInt(a),difficulty:parseInt(s),nonce:h,extraData:f,mixHash:n,coinbase:r,baseFeePerGas:c},hardfork:void 0,hardforks:[],bootstrapNodes:[],consensus:o.clique!==void 0?{type:"poa",algorithm:"clique",clique:{period:o.clique.period??o.clique.blockperiodseconds,epoch:o.clique.epoch??o.clique.epochlength}}:{type:"pow",algorithm:"ethash",ethash:{}}},B={[P.Hardfork.Homestead]:{name:"homesteadBlock"},[P.Hardfork.Dao]:{name:"daoForkBlock"},[P.Hardfork.TangerineWhistle]:{name:"eip150Block"},[P.Hardfork.SpuriousDragon]:{name:"eip155Block"},[P.Hardfork.Byzantium]:{name:"byzantiumBlock"},[P.Hardfork.Constantinople]:{name:"constantinopleBlock"},[P.Hardfork.Petersburg]:{name:"petersburgBlock"},[P.Hardfork.Istanbul]:{name:"istanbulBlock"},[P.Hardfork.MuirGlacier]:{name:"muirGlacierBlock"},[P.Hardfork.Berlin]:{name:"berlinBlock"},[P.Hardfork.London]:{name:"londonBlock"},[P.Hardfork.MergeForkIdTransition]:{name:"mergeForkBlock",postMerge:e},[P.Hardfork.Shanghai]:{name:"shanghaiTime",postMerge:!0,isTimestamp:!0},[P.Hardfork.ShardingForkDev]:{name:"shardingForkTime",postMerge:!0,isTimestamp:!0}},H=Object.keys(B).reduce((b,y)=>(b[B[y].name]=y,b),{}),ae=Object.keys(o).filter(b=>H[b]!==void 0&&o[b]!==void 0&&o[b]!==null);if(k.hardforks=ae.map(b=>({name:H[b],block:B[H[b]].isTimestamp===!0||typeof o[b]!="number"?null:o[b],timestamp:B[H[b]].isTimestamp===!0&&typeof o[b]=="number"?o[b]:void 0})).filter(b=>b.block!==null||b.timestamp!==void 0),k.hardforks.sort(function(b,y){return(b.block??1/0)-(y.block??1/0)}),k.hardforks.sort(function(b,y){return(b.timestamp??$)-(y.timestamp??$)}),o.terminalTotalDifficulty!==void 0){const b={name:P.Hardfork.Merge,ttd:o.terminalTotalDifficulty,block:null},y=k.hardforks.findIndex(xe=>{var $e;return(($e=B[xe.name])==null?void 0:$e.postMerge)===!0});y!==-1?k.hardforks.splice(y,0,b):k.hardforks.push(b)}const A=k.hardforks.length>0?k.hardforks.slice(-1)[0]:void 0;return k.hardfork=A==null?void 0:A.name,k.hardforks.unshift({name:P.Hardfork.Chainstart,block:0}),k}function Ud(i,e,t){try{if(["config","difficulty","gasLimit","alloc"].some(o=>!(o in i)))throw new Error("Invalid format, expected geth genesis fields missing");return e!==void 0&&(i.name=e),zd(i,t)}catch(o){throw new Error(`Error parsing parameters file: ${o.message}`)}}z.parseGethGenesis=Ud;Object.defineProperty(ee,"__esModule",{value:!0});ee.Common=void 0;const E=w,jd=Se,Kd=He,Vd=Ue,Jd=ot,Yd=lt,Wd=wt,Xd=Rt,C=te,v=oe,Zd=se,Qd=z;class T extends Kd.EventEmitter{constructor(e){super(),this._eips=[],this._customChains=e.customChains??[],this._chainParams=this.setChain(e.chain),this.DEFAULT_HARDFORK=this._chainParams.defaultHardfork??v.Hardfork.Merge,this.HARDFORK_CHANGES=this.hardforks().map(t=>[t.name,Zd.hardforks[t.name]]),this._hardfork=this.DEFAULT_HARDFORK,e.hardfork!==void 0&&this.setHardfork(e.hardfork),e.eips&&this.setEIPs(e.eips)}static custom(e,t={}){const o=t.baseChain??"mainnet",s={...T._getChainParams(o)};if(s.name="custom-chain",typeof e!="string")return new T({chain:{...s,...e},...t});if(e===v.CustomChain.PolygonMainnet)return T.custom({name:v.CustomChain.PolygonMainnet,chainId:137,networkId:137},t);if(e===v.CustomChain.PolygonMumbai)return T.custom({name:v.CustomChain.PolygonMumbai,chainId:80001,networkId:80001},t);if(e===v.CustomChain.ArbitrumRinkebyTestnet)return T.custom({name:v.CustomChain.ArbitrumRinkebyTestnet,chainId:421611,networkId:421611},t);if(e===v.CustomChain.ArbitrumOne)return T.custom({name:v.CustomChain.ArbitrumOne,chainId:42161,networkId:42161},t);if(e===v.CustomChain.xDaiChain)return T.custom({name:v.CustomChain.xDaiChain,chainId:100,networkId:100},t);if(e===v.CustomChain.OptimisticKovan)return T.custom({name:v.CustomChain.OptimisticKovan,chainId:69,networkId:69},{hardfork:v.Hardfork.Berlin,...t});if(e===v.CustomChain.OptimisticEthereum)return T.custom({name:v.CustomChain.OptimisticEthereum,chainId:10,networkId:10},{hardfork:v.Hardfork.Berlin,...t});throw new Error(`Custom chain ${e} not supported`)}static fromGethGenesis(e,{chain:t,eips:o,genesisHash:s,hardfork:n,mergeForkIdPostMerge:a}){const r=(0,Qd.parseGethGenesis)(e,t,a),c=new T({chain:r.name??"custom",customChains:[r],eips:o,hardfork:n??r.hardfork});return s!==void 0&&c.setForkHashes(s),c}static isSupportedChainId(e){return!!this._getInitializedChains().names[e.toString()]}static _getChainParams(e,t){const o=this._getInitializedChains(t);if(typeof e=="number"||typeof e=="bigint"){if(e=e.toString(),o.names[e]){const s=o.names[e];return o[s]}throw new Error(`Chain with ID ${e} not supported`)}if(o[e]!==void 0)return o[e];throw new Error(`Chain with name ${e} not supported`)}setChain(e){if(typeof e=="number"||typeof e=="bigint"||typeof e=="string")this._chainParams=T._getChainParams(e,this._customChains);else if(typeof e=="object"){if(this._customChains.length>0)throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");const t=["networkId","genesis","hardforks","bootstrapNodes"];for(const o of t)if(!(o in e))throw new Error(`Missing required chain parameter: ${o}`);this._chainParams=e}else throw new Error("Wrong input format");for(const t of this.hardforks())if(t.block===void 0)throw new Error("Hardfork cannot have undefined block number");return this._chainParams}setHardfork(e){let t=!1;for(const o of this.HARDFORK_CHANGES)o[0]===e&&(this._hardfork!==e&&(this._hardfork=e,this.emit("hardforkChanged",e)),t=!0);if(!t)throw new Error(`Hardfork with name ${e} not supported`)}getHardforkByBlockNumber(e,t,o){e=(0,E.toType)(e,E.TypeOutput.BigInt),t=(0,E.toType)(t,E.TypeOutput.BigInt),o=(0,E.toType)(o,E.TypeOutput.Number);const s=this.hardforks().filter(d=>d.block!==null||d.ttd!==null&&d.ttd!==void 0||d.timestamp!==void 0),n=s.findIndex(d=>d.ttd!==null&&d.ttd!==void 0);if(s.slice(n+1).findIndex(d=>d.ttd!==null&&d.ttd!==void 0)>=0)throw Error("More than one merge hardforks found with ttd specified");let r=s.findIndex(d=>d.block!==null&&d.block>e||o!==void 0&&Number(d.timestamp)>o);if(r===-1)r=s.length;else if(r===0)throw Error("Must have at least one hardfork at block 0");if(o===void 0){const d=s.slice(0,r).reverse().findIndex(h=>h.block!==null||h.ttd!==void 0);r=r-d}if(r=r-1,s[r].block===null&&s[r].timestamp===void 0)(t==null||BigInt(s[r].ttd)>t)&&(r-=1);else if(n>=0&&t!==void 0&&t!==null){if(r>=n&&BigInt(s[n].ttd)>t)throw Error("Maximum HF determined by total difficulty is lower than the block number HF");if(r<n&&BigInt(s[n].ttd)<=t)throw Error("HF determined by block number is lower than the minimum total difficulty HF")}const c=r;for(;r<s.length-1&&!(s[r].block!==s[r+1].block||s[r].timestamp!==s[r+1].timestamp);r++);if(o){if(s.slice(0,c).reduce(($,I)=>Math.max(Number(I.timestamp??"0"),$),0)>o)throw Error("Maximum HF determined by timestamp is lower than the block number/ttd HF");if(s.slice(r+1).reduce(($,I)=>Math.min(Number(I.timestamp??o),$),o)<o)throw Error("Maximum HF determined by block number/ttd is lower than timestamp HF")}return s[r].name}setHardforkByBlockNumber(e,t,o){const s=this.getHardforkByBlockNumber(e,t,o);return this.setHardfork(s),s}_getHardfork(e){const t=this.hardforks();for(const o of t)if(o.name===e)return o;return null}setEIPs(e=[]){for(const t of e){if(!(t in C.EIPs))throw new Error(`${t} not supported`);const o=this.gteHardfork(C.EIPs[t].minimumHardfork);if(!o)throw new Error(`${t} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${o}`);if(C.EIPs[t].requiredEIPs!==void 0){for(const s of C.EIPs[t].requiredEIPs)if(!(e.includes(s)||this.isActivatedEIP(s)))throw new Error(`${t} requires EIP ${s}, but is not included in the EIP list`)}}this._eips=e}param(e,t){let o;for(const s of this._eips)if(o=this.paramByEIP(e,t,s),o!==void 0)return o;return this.paramByHardfork(e,t,this._hardfork)}paramByHardfork(e,t,o){let s=null;for(const n of this.HARDFORK_CHANGES){if("eips"in n[1]){const a=n[1].eips;for(const r of a){const c=this.paramByEIP(e,t,r);s=typeof c=="bigint"?c:s}}else{if(n[1][e]===void 0)throw new Error(`Topic ${e} not defined`);n[1][e][t]!==void 0&&(s=n[1][e][t].v)}if(n[0]===o)break}return BigInt(s??0)}paramByEIP(e,t,o){if(!(o in C.EIPs))throw new Error(`${o} not supported`);const s=C.EIPs[o];if(!(e in s))throw new Error(`Topic ${e} not defined`);if(s[e][t]===void 0)return;const n=s[e][t].v;return BigInt(n)}paramByBlock(e,t,o,s,n){const a=this.getHardforkByBlockNumber(o,s,n);return this.paramByHardfork(e,t,a)}isActivatedEIP(e){if(this.eips().includes(e))return!0;for(const t of this.HARDFORK_CHANGES){const o=t[1];if(this.gteHardfork(o.name)&&"eips"in o&&o.eips.includes(e))return!0}return!1}hardforkIsActiveOnBlock(e,t){t=(0,E.toType)(t,E.TypeOutput.BigInt),e=e??this._hardfork;const o=this.hardforkBlock(e);return typeof o=="bigint"&&o!==BigInt(0)&&t>=o}activeOnBlock(e){return this.hardforkIsActiveOnBlock(null,e)}hardforkGteHardfork(e,t){e=e??this._hardfork;const o=this.hardforks();let s=-1,n=-1,a=0;for(const r of o)r.name===e&&(s=a),r.name===t&&(n=a),a+=1;return s>=n&&n!==-1}gteHardfork(e){return this.hardforkGteHardfork(null,e)}hardforkBlock(e){var o;e=e??this._hardfork;const t=(o=this._getHardfork(e))==null?void 0:o.block;return t==null?null:BigInt(t)}hardforkTimestamp(e){var o;e=e??this._hardfork;const t=(o=this._getHardfork(e))==null?void 0:o.timestamp;return t==null?null:BigInt(t)}eipBlock(e){for(const t of this.HARDFORK_CHANGES){const o=t[1];if("eips"in o&&o.eips.includes(e))return this.hardforkBlock(t[0])}return null}hardforkTTD(e){var o;e=e??this._hardfork;const t=(o=this._getHardfork(e))==null?void 0:o.ttd;return t==null?null:BigInt(t)}isHardforkBlock(e,t){e=(0,E.toType)(e,E.TypeOutput.BigInt),t=t??this._hardfork;const o=this.hardforkBlock(t);return typeof o=="bigint"&&o!==BigInt(0)?o===e:!1}nextHardforkBlockOrTimestamp(e){e=e??this._hardfork;const t=this.hardforks();let o=t.findIndex(r=>r.name===e);if(e===v.Hardfork.Merge&&(o-=1),o<0)return null;let s=t[o].timestamp??t[o].block;s=s!=null?Number(s):null;const n=t.slice(o+1).find(r=>{let c=r.timestamp??r.block;return c=c!=null?Number(c):null,r.name!==v.Hardfork.Merge&&c!==null&&c!==void 0&&c!==s});if(n===void 0)return null;const a=n.timestamp??n.block;return a==null?null:BigInt(a)}nextHardforkBlock(e){e=e??this._hardfork;let t=this.hardforkBlock(e);if(t===null&&e===v.Hardfork.Merge){const s=this.hardforks(),n=s.findIndex(a=>a.ttd!==null&&a.ttd!==void 0);if(n<0)throw Error("Merge hardfork should have been found");t=this.hardforkBlock(s[n-1].name)}return t===null?null:this.hardforks().reduce((s,n)=>{const a=BigInt(n.block===null||n.ttd!==void 0&&n.ttd!==null?0:n.block);return a>t&&s===null?a:s},null)}isNextHardforkBlock(e,t){e=(0,E.toType)(e,E.TypeOutput.BigInt),t=t??this._hardfork;const o=this.nextHardforkBlock(t);return o===null?!1:o===e}_calcForkHash(e,t){let o=u.alloc(0),s=0;for(const r of this.hardforks()){const{block:c,timestamp:f,name:d}=r;let h=f??c;if(h=h!==null?Number(h):null,typeof h=="number"&&h!==0&&h!==s&&d!==v.Hardfork.Merge){const $=u.from(h.toString(16).padStart(16,"0"),"hex");o=u.concat([o,$]),s=h}if(r.name===e)break}const n=u.concat([t,o]);return`0x${(0,E.intToBuffer)((0,jd.buf)(n)>>>0).toString("hex")}`}forkHash(e,t){e=e??this._hardfork;const o=this._getHardfork(e);if(o===null||(o==null?void 0:o.block)===null&&(o==null?void 0:o.timestamp)===void 0&&(o==null?void 0:o.ttd)===void 0){const s="No fork hash calculation possible for future hardfork";throw new Error(s)}if((o==null?void 0:o.forkHash)!==null&&(o==null?void 0:o.forkHash)!==void 0)return o.forkHash;if(!t)throw new Error("genesisHash required for forkHash calculation");return this._calcForkHash(e,t)}hardforkForForkHash(e){const t=this.hardforks().filter(o=>o.forkHash===e);return t.length>=1?t[t.length-1]:null}setForkHashes(e){for(const t of this.hardforks()){const o=t.timestamp??t.block;(t.forkHash===null||t.forkHash===void 0)&&(o!=null||typeof t.ttd<"u")&&(t.forkHash=this.forkHash(t.name,e))}}genesis(){return this._chainParams.genesis}hardforks(){return this._chainParams.hardforks}bootstrapNodes(){return this._chainParams.bootstrapNodes}dnsNetworks(){return this._chainParams.dnsNetworks}hardfork(){return this._hardfork}chainId(){return BigInt(this._chainParams.chainId)}chainName(){return this._chainParams.name}networkId(){return BigInt(this._chainParams.networkId)}eips(){return this._eips}consensusType(){const e=this.hardfork();let t;for(const o of this.HARDFORK_CHANGES)if("consensus"in o[1]&&(t=o[1].consensus.type),o[0]===e)break;return t??this._chainParams.consensus.type}consensusAlgorithm(){const e=this.hardfork();let t;for(const o of this.HARDFORK_CHANGES)if("consensus"in o[1]&&(t=o[1].consensus.algorithm),o[0]===e)break;return t??this._chainParams.consensus.algorithm}consensusConfig(){const e=this.hardfork();let t;for(const o of this.HARDFORK_CHANGES)if("consensus"in o[1]&&(t=o[1].consensus[o[1].consensus.algorithm]),o[0]===e)break;return t??this._chainParams.consensus[this.consensusAlgorithm()]??{}}copy(){const e=Object.assign(Object.create(Object.getPrototypeOf(this)),this);return e.removeAllListeners(),e}static _getInitializedChains(e){const t={};for(const[s,n]of Object.entries(v.Chain))t[n]=s.toLowerCase();const o={mainnet:Jd,ropsten:Wd,rinkeby:Yd,goerli:Vd,sepolia:Xd};if(e)for(const s of e){const{name:n}=s;t[s.chainId.toString()]=n,o[n]=s}return o.names=t,o}}ee.Common=T;var Be={};Object.defineProperty(Be,"__esModule",{value:!0});(function(i){var e=x&&x.__createBinding||(Object.create?function(o,s,n,a){a===void 0&&(a=n);var r=Object.getOwnPropertyDescriptor(s,n);(!r||("get"in r?!s.__esModule:r.writable||r.configurable))&&(r={enumerable:!0,get:function(){return s[n]}}),Object.defineProperty(o,a,r)}:function(o,s,n,a){a===void 0&&(a=n),o[a]=s[n]}),t=x&&x.__exportStar||function(o,s){for(var n in o)n!=="default"&&!Object.prototype.hasOwnProperty.call(s,n)&&e(s,o,n)};Object.defineProperty(i,"__esModule",{value:!0}),t(ee,i),t(oe,i),t(Be,i),t(z,i)})(we);var U={};(function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.isAccessList=i.isAccessListBuffer=i.Capability=void 0,function(o){o[o.EIP155ReplayProtection=155]="EIP155ReplayProtection",o[o.EIP1559FeeMarket=1559]="EIP1559FeeMarket",o[o.EIP2718TypedTransaction=2718]="EIP2718TypedTransaction",o[o.EIP2930AccessLists=2930]="EIP2930AccessLists"}(i.Capability||(i.Capability={}));function e(o){if(o.length===0)return!0;const s=o[0];return!!Array.isArray(s)}i.isAccessListBuffer=e;function t(o){return!e(o)}i.isAccessList=t})(U);var S={};Object.defineProperty(S,"__esModule",{value:!0});S.AccessLists=S.checkMaxInitCodeSize=void 0;const L=w,ef=U;function tf(i,e){const t=i.param("vm","maxInitCodeSize");if(t&&BigInt(e)>t)throw new Error(`the initcode size of this transaction is too large: it is ${e} while the max is ${i.param("vm","maxInitCodeSize")}`)}S.checkMaxInitCodeSize=tf;class of{static getAccessListData(e){let t,o;if((0,ef.isAccessList)(e)){t=e;const s=[];for(let n=0;n<e.length;n++){const a=e[n],r=(0,L.toBuffer)(a.address),c=[];for(let f=0;f<a.storageKeys.length;f++)c.push((0,L.toBuffer)(a.storageKeys[f]));s.push([r,c])}o=s}else{o=e??[];const s=[];for(let n=0;n<o.length;n++){const a=o[n],r=(0,L.bufferToHex)(a[0]),c=[];for(let d=0;d<a[1].length;d++)c.push((0,L.bufferToHex)(a[1][d]));const f={address:r,storageKeys:c};s.push(f)}t=s}return{AccessListJSON:t,accessList:o}}static verifyAccessList(e){for(let t=0;t<e.length;t++){const o=e[t],s=o[0],n=o[1];if(o[2]!==void 0)throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");if(s.length!==20)throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");for(let a=0;a<n.length;a++)if(n[a].length!==32)throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")}}static getAccessListJSON(e){const t=[];for(let o=0;o<e.length;o++){const s=e[o],n={address:"0x"+(0,L.setLengthLeft)(s[0],20).toString("hex"),storageKeys:[]},a=s[1];for(let r=0;r<a.length;r++){const c=a[r];n.storageKeys.push("0x"+(0,L.setLengthLeft)(c,32).toString("hex"))}t.push(n)}return t}static getDataFeeEIP2930(e,t){const o=t.param("gasPrices","accessListStorageKeyCost"),s=t.param("gasPrices","accessListAddressCost");let n=0;for(let r=0;r<e.length;r++){const f=e[r][1];n+=f.length}return e.length*Number(s)+n*Number(o)}}S.AccessLists=of;Object.defineProperty(G,"__esModule",{value:!0});G.BaseTransaction=void 0;const O=we,p=w,ie=U,sf=S;class nf{constructor(e,t){this.cache={hash:void 0,dataFee:void 0},this.activeCapabilities=[],this.DEFAULT_CHAIN=O.Chain.Mainnet,this.DEFAULT_HARDFORK=O.Hardfork.Merge;const{nonce:o,gasLimit:s,to:n,value:a,data:r,v:c,r:f,s:d,type:h}=e;this._type=Number((0,p.bufferToBigInt)((0,p.toBuffer)(h))),this.txOptions=t;const $=(0,p.toBuffer)(n===""?"0x":n),I=(0,p.toBuffer)(c===""?"0x":c),k=(0,p.toBuffer)(f===""?"0x":f),B=(0,p.toBuffer)(d===""?"0x":d);this.nonce=(0,p.bufferToBigInt)((0,p.toBuffer)(o===""?"0x":o)),this.gasLimit=(0,p.bufferToBigInt)((0,p.toBuffer)(s===""?"0x":s)),this.to=$.length>0?new p.Address($):void 0,this.value=(0,p.bufferToBigInt)((0,p.toBuffer)(a===""?"0x":a)),this.data=(0,p.toBuffer)(r===""?"0x":r),this.v=I.length>0?(0,p.bufferToBigInt)(I):void 0,this.r=k.length>0?(0,p.bufferToBigInt)(k):void 0,this.s=B.length>0?(0,p.bufferToBigInt)(B):void 0,this._validateCannotExceedMaxInteger({value:this.value,r:this.r,s:this.s}),this._validateCannotExceedMaxInteger({gasLimit:this.gasLimit},64),this._validateCannotExceedMaxInteger({nonce:this.nonce},64,!0);const H=this.to===void 0||this.to===null,ae=t.allowUnlimitedInitCodeSize??!1,A=t.common??this._getCommon();H&&A.isActivatedEIP(3860)&&ae===!1&&(0,sf.checkMaxInitCodeSize)(A,this.data.length)}get type(){return this._type}supports(e){return this.activeCapabilities.includes(e)}validate(e=!1){const t=[];return this.getBaseFee()>this.gasLimit&&t.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`),this.isSigned()&&!this.verifySignature()&&t.push("Invalid Signature"),e?t:t.length===0}_validateYParity(){const{v:e}=this;if(e!==void 0&&e!==BigInt(0)&&e!==BigInt(1)){const t=this._errorMsg("The y-parity of the transaction should either be 0 or 1");throw new Error(t)}}_validateHighS(){const{s:e}=this;if(this.common.gteHardfork("homestead")&&e!==void 0&&e>p.SECP256K1_ORDER_DIV_2){const t=this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");throw new Error(t)}}getBaseFee(){const e=this.common.param("gasPrices","tx");let t=this.getDataFee();if(e&&(t+=e),this.common.gteHardfork("homestead")&&this.toCreationAddress()){const o=this.common.param("gasPrices","txCreation");o&&(t+=o)}return t}getDataFee(){const e=this.common.param("gasPrices","txDataZero"),t=this.common.param("gasPrices","txDataNonZero");let o=BigInt(0);for(let s=0;s<this.data.length;s++)this.data[s]===0?o+=e:o+=t;if((this.to===void 0||this.to===null)&&this.common.isActivatedEIP(3860)){const s=BigInt(Math.ceil(this.data.length/32)),n=this.common.param("gasPrices","initCodeWordCost")*s;o+=n}return o}toCreationAddress(){return this.to===void 0||this.to.buf.length===0}isSigned(){const{v:e,r:t,s:o}=this;return!(e===void 0||t===void 0||o===void 0)}verifySignature(){try{const e=this.getSenderPublicKey();return(0,p.unpadBuffer)(e).length!==0}catch{return!1}}getSenderAddress(){return new p.Address((0,p.publicToAddress)(this.getSenderPublicKey()))}sign(e){if(e.length!==32){const c=this._errorMsg("Private key must be 32 bytes in length.");throw new Error(c)}let t=!1;this.type===0&&this.common.gteHardfork("spuriousDragon")&&!this.supports(ie.Capability.EIP155ReplayProtection)&&(this.activeCapabilities.push(ie.Capability.EIP155ReplayProtection),t=!0);const o=this.getMessageToSign(!0),{v:s,r:n,s:a}=(0,p.ecsign)(o,e),r=this._processSignature(s,n,a);if(t){const c=this.activeCapabilities.indexOf(ie.Capability.EIP155ReplayProtection);c>-1&&this.activeCapabilities.splice(c,1)}return r}_getCommon(e,t){if(t!==void 0){const o=(0,p.bufferToBigInt)((0,p.toBuffer)(t));if(e){if(e.chainId()!==o){const s=this._errorMsg("The chain ID does not match the chain ID of Common");throw new Error(s)}return e.copy()}else return O.Common.isSupportedChainId(o)?new O.Common({chain:o,hardfork:this.DEFAULT_HARDFORK}):O.Common.custom({name:"custom-chain",networkId:o,chainId:o},{baseChain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}else return(e==null?void 0:e.copy())??new O.Common({chain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}_validateCannotExceedMaxInteger(e,t=256,o=!1){for(const[s,n]of Object.entries(e))switch(t){case 64:if(o){if(n!==void 0&&n>=p.MAX_UINT64){const a=this._errorMsg(`${s} cannot equal or exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(a)}}else if(n!==void 0&&n>p.MAX_UINT64){const a=this._errorMsg(`${s} cannot exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(a)}break;case 256:if(o){if(n!==void 0&&n>=p.MAX_INTEGER){const a=this._errorMsg(`${s} cannot equal or exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(a)}}else if(n!==void 0&&n>p.MAX_INTEGER){const a=this._errorMsg(`${s} cannot exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(a)}break;default:{const a=this._errorMsg("unimplemented bits value");throw new Error(a)}}}static _validateNotArray(e){const t=["nonce","gasPrice","gasLimit","to","value","data","v","r","s","type","baseFee","maxFeePerGas","chainId"];for(const[o,s]of Object.entries(e))if(t.includes(o)&&Array.isArray(s))throw new Error(`${o} cannot be an array`)}_getSharedErrorPostfix(){let e="";try{e=this.isSigned()?(0,p.bufferToHex)(this.hash()):"not available (unsigned)"}catch{e="error"}let t="";try{t=this.isSigned().toString()}catch{e="error"}let o="";try{o=this.common.hardfork()}catch{o="error"}let s=`tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;return s+=`signed=${t} hf=${o}`,s}}G.BaseTransaction=nf;Object.defineProperty(q,"__esModule",{value:!0});q.FeeMarketEIP1559Transaction=void 0;const ce=pe,l=w,de=be,ke=G,V=S,le=2,fe=u.from(le.toString(16).padStart(2,"0"),"hex");class D extends ke.BaseTransaction{constructor(e,t={}){super({...e,type:le},t),this.DEFAULT_HARDFORK="london";const{chainId:o,accessList:s,maxFeePerGas:n,maxPriorityFeePerGas:a}=e;if(this.common=this._getCommon(t.common,o),this.chainId=this.common.chainId(),this.common.isActivatedEIP(1559)===!1)throw new Error("EIP-1559 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const r=V.AccessLists.getAccessListData(s??[]);if(this.accessList=r.accessList,this.AccessListJSON=r.AccessListJSON,V.AccessLists.verifyAccessList(this.accessList),this.maxFeePerGas=(0,l.bufferToBigInt)((0,l.toBuffer)(n===""?"0x":n)),this.maxPriorityFeePerGas=(0,l.bufferToBigInt)((0,l.toBuffer)(a===""?"0x":a)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),ke.BaseTransaction._validateNotArray(e),this.gasLimit*this.maxFeePerGas>l.MAX_INTEGER){const f=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(f)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const f=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(f)}this._validateYParity(),this._validateHighS(),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new D(e,t)}static fromSerializedTx(e,t={}){if(!e.slice(0,1).equals(fe))throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${le}, received: ${e.slice(0,1).toString("hex")}`);const o=(0,l.arrToBufArr)(ce.RLP.decode(e.slice(1)));if(!Array.isArray(o))throw new Error("Invalid serialized tx input: must be array");return D.fromValuesArray(o,t)}static fromValuesArray(e,t={}){if(e.length!==9&&e.length!==12)throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");const[o,s,n,a,r,c,f,d,h,$,I,k]=e;return this._validateNotArray({chainId:o,v:$}),(0,l.validateNoLeadingZeroes)({nonce:s,maxPriorityFeePerGas:n,maxFeePerGas:a,gasLimit:r,value:f,v:$,r:I,s:k}),new D({chainId:(0,l.bufferToBigInt)(o),nonce:s,maxPriorityFeePerGas:n,maxFeePerGas:a,gasLimit:r,to:c,value:f,data:d,accessList:h??[],v:$!==void 0?(0,l.bufferToBigInt)($):void 0,r:I,s:k},t)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(V.AccessLists.getDataFeeEIP2930(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(e=BigInt(0)){const t=this.maxPriorityFeePerGas,o=this.maxFeePerGas-e,n=(t<o?t:o)+e;return this.gasLimit*n+this.value}raw(){return[(0,l.bigIntToUnpaddedBuffer)(this.chainId),(0,l.bigIntToUnpaddedBuffer)(this.nonce),(0,l.bigIntToUnpaddedBuffer)(this.maxPriorityFeePerGas),(0,l.bigIntToUnpaddedBuffer)(this.maxFeePerGas),(0,l.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:u.from([]),(0,l.bigIntToUnpaddedBuffer)(this.value),this.data,this.accessList,this.v!==void 0?(0,l.bigIntToUnpaddedBuffer)(this.v):u.from([]),this.r!==void 0?(0,l.bigIntToUnpaddedBuffer)(this.r):u.from([]),this.s!==void 0?(0,l.bigIntToUnpaddedBuffer)(this.s):u.from([])]}serialize(){const e=this.raw();return u.concat([fe,u.from(ce.RLP.encode((0,l.bufArrToArr)(e)))])}getMessageToSign(e=!0){const t=this.raw().slice(0,9),o=u.concat([fe,u.from(ce.RLP.encode((0,l.bufArrToArr)(t)))]);return e?u.from((0,de.keccak256)(o)):o}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=u.from((0,de.keccak256)(this.serialize()))),this.cache.hash):u.from((0,de.keccak256)(this.serialize()))}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const n=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(n)}const e=this.getMessageToVerifySignature(),{v:t,r:o,s}=this;this._validateHighS();try{return(0,l.ecrecover)(e,t+BigInt(27),(0,l.bigIntToUnpaddedBuffer)(o),(0,l.bigIntToUnpaddedBuffer)(s))}catch{const a=this._errorMsg("Invalid Signature");throw new Error(a)}}_processSignature(e,t,o){const s={...this.txOptions,common:this.common};return D.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:(0,l.bufferToBigInt)(t),s:(0,l.bufferToBigInt)(o)},s)}toJSON(){const e=V.AccessLists.getAccessListJSON(this.accessList);return{chainId:(0,l.bigIntToHex)(this.chainId),nonce:(0,l.bigIntToHex)(this.nonce),maxPriorityFeePerGas:(0,l.bigIntToHex)(this.maxPriorityFeePerGas),maxFeePerGas:(0,l.bigIntToHex)(this.maxFeePerGas),gasLimit:(0,l.bigIntToHex)(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:(0,l.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),accessList:e,v:this.v!==void 0?(0,l.bigIntToHex)(this.v):void 0,r:this.r!==void 0?(0,l.bigIntToHex)(this.r):void 0,s:this.s!==void 0?(0,l.bigIntToHex)(this.s):void 0}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}q.FeeMarketEIP1559Transaction=D;var j={};Object.defineProperty(j,"__esModule",{value:!0});j.AccessListEIP2930Transaction=void 0;const ue=pe,g=w,me=be,Pe=G,J=S,ge=1,he=u.from(ge.toString(16).padStart(2,"0"),"hex");class R extends Pe.BaseTransaction{constructor(e,t={}){super({...e,type:ge},t),this.DEFAULT_HARDFORK="berlin";const{chainId:o,accessList:s,gasPrice:n}=e;if(this.common=this._getCommon(t.common,o),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(2930))throw new Error("EIP-2930 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([2718,2930]);const a=J.AccessLists.getAccessListData(s??[]);if(this.accessList=a.accessList,this.AccessListJSON=a.AccessListJSON,J.AccessLists.verifyAccessList(this.accessList),this.gasPrice=(0,g.bufferToBigInt)((0,g.toBuffer)(n===""?"0x":n)),this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),Pe.BaseTransaction._validateNotArray(e),this.gasPrice*this.gasLimit>g.MAX_INTEGER){const c=this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");throw new Error(c)}this._validateYParity(),this._validateHighS(),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new R(e,t)}static fromSerializedTx(e,t={}){if(!e.slice(0,1).equals(he))throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${ge}, received: ${e.slice(0,1).toString("hex")}`);const o=(0,g.arrToBufArr)(ue.RLP.decode(Uint8Array.from(e.slice(1))));if(!Array.isArray(o))throw new Error("Invalid serialized tx input: must be array");return R.fromValuesArray(o,t)}static fromValuesArray(e,t={}){if(e.length!==8&&e.length!==11)throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");const[o,s,n,a,r,c,f,d,h,$,I]=e;this._validateNotArray({chainId:o,v:h}),(0,g.validateNoLeadingZeroes)({nonce:s,gasPrice:n,gasLimit:a,value:c,v:h,r:$,s:I});const k=[];return new R({chainId:(0,g.bufferToBigInt)(o),nonce:s,gasPrice:n,gasLimit:a,to:r,value:c,data:f,accessList:d??k,v:h!==void 0?(0,g.bufferToBigInt)(h):void 0,r:$,s:I},t)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(J.AccessLists.getDataFeeEIP2930(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}raw(){return[(0,g.bigIntToUnpaddedBuffer)(this.chainId),(0,g.bigIntToUnpaddedBuffer)(this.nonce),(0,g.bigIntToUnpaddedBuffer)(this.gasPrice),(0,g.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:u.from([]),(0,g.bigIntToUnpaddedBuffer)(this.value),this.data,this.accessList,this.v!==void 0?(0,g.bigIntToUnpaddedBuffer)(this.v):u.from([]),this.r!==void 0?(0,g.bigIntToUnpaddedBuffer)(this.r):u.from([]),this.s!==void 0?(0,g.bigIntToUnpaddedBuffer)(this.s):u.from([])]}serialize(){const e=this.raw();return u.concat([he,u.from(ue.RLP.encode((0,g.bufArrToArr)(e)))])}getMessageToSign(e=!0){const t=this.raw().slice(0,8),o=u.concat([he,u.from(ue.RLP.encode((0,g.bufArrToArr)(t)))]);return e?u.from((0,me.keccak256)(o)):o}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=u.from((0,me.keccak256)(this.serialize()))),this.cache.hash):u.from((0,me.keccak256)(this.serialize()))}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const n=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(n)}const e=this.getMessageToVerifySignature(),{v:t,r:o,s}=this;this._validateHighS();try{return(0,g.ecrecover)(e,t+BigInt(27),(0,g.bigIntToUnpaddedBuffer)(o),(0,g.bigIntToUnpaddedBuffer)(s))}catch{const a=this._errorMsg("Invalid Signature");throw new Error(a)}}_processSignature(e,t,o){const s={...this.txOptions,common:this.common};return R.fromTxData({chainId:this.chainId,nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:(0,g.bufferToBigInt)(t),s:(0,g.bufferToBigInt)(o)},s)}toJSON(){const e=J.AccessLists.getAccessListJSON(this.accessList);return{chainId:(0,g.bigIntToHex)(this.chainId),nonce:(0,g.bigIntToHex)(this.nonce),gasPrice:(0,g.bigIntToHex)(this.gasPrice),gasLimit:(0,g.bigIntToHex)(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:(0,g.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),accessList:e,v:this.v!==void 0?(0,g.bigIntToHex)(this.v):void 0,r:this.r!==void 0?(0,g.bigIntToHex)(this.r):void 0,s:this.s!==void 0?(0,g.bigIntToHex)(this.s):void 0}}errorStr(){var t;let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice} accessListCount=${((t=this.accessList)==null?void 0:t.length)??0}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}j.AccessListEIP2930Transaction=R;var K={};Object.defineProperty(K,"__esModule",{value:!0});K.Transaction=void 0;const _=pe,m=w,Y=be,Ie=G,M=U,rf=0;function Ee(i,e){const t=Number(i),o=Number(e)*2;return t===o+35||t===o+36}class N extends Ie.BaseTransaction{constructor(e,t={}){if(super({...e,type:rf},t),this.common=this._validateTxV(this.v,t.common),this.gasPrice=(0,m.bufferToBigInt)((0,m.toBuffer)(e.gasPrice===""?"0x":e.gasPrice)),this.gasPrice*this.gasLimit>m.MAX_INTEGER){const s=this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");throw new Error(s)}this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),Ie.BaseTransaction._validateNotArray(e),this.common.gteHardfork("spuriousDragon")&&(this.isSigned()?Ee(this.v,this.common.chainId())&&this.activeCapabilities.push(M.Capability.EIP155ReplayProtection):this.activeCapabilities.push(M.Capability.EIP155ReplayProtection)),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new N(e,t)}static fromSerializedTx(e,t={}){const o=(0,m.arrToBufArr)(_.RLP.decode(Uint8Array.from(e)));if(!Array.isArray(o))throw new Error("Invalid serialized tx input. Must be array");return this.fromValuesArray(o,t)}static fromValuesArray(e,t={}){if(e.length!==6&&e.length!==9)throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");const[o,s,n,a,r,c,f,d,h]=e;return(0,m.validateNoLeadingZeroes)({nonce:o,gasPrice:s,gasLimit:n,value:r,v:f,r:d,s:h}),new N({nonce:o,gasPrice:s,gasLimit:n,to:a,value:r,data:c,v:f,r:d,s:h},t)}raw(){return[(0,m.bigIntToUnpaddedBuffer)(this.nonce),(0,m.bigIntToUnpaddedBuffer)(this.gasPrice),(0,m.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:u.from([]),(0,m.bigIntToUnpaddedBuffer)(this.value),this.data,this.v!==void 0?(0,m.bigIntToUnpaddedBuffer)(this.v):u.from([]),this.r!==void 0?(0,m.bigIntToUnpaddedBuffer)(this.r):u.from([]),this.s!==void 0?(0,m.bigIntToUnpaddedBuffer)(this.s):u.from([])]}serialize(){return u.from(_.RLP.encode((0,m.bufArrToArr)(this.raw())))}_getMessageToSign(){const e=[(0,m.bigIntToUnpaddedBuffer)(this.nonce),(0,m.bigIntToUnpaddedBuffer)(this.gasPrice),(0,m.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:u.from([]),(0,m.bigIntToUnpaddedBuffer)(this.value),this.data];return this.supports(M.Capability.EIP155ReplayProtection)&&(e.push((0,m.bigIntToUnpaddedBuffer)(this.common.chainId())),e.push((0,m.unpadBuffer)((0,m.toBuffer)(0))),e.push((0,m.unpadBuffer)((0,m.toBuffer)(0)))),e}getMessageToSign(e=!0){const t=this._getMessageToSign();return e?u.from((0,Y.keccak256)(_.RLP.encode((0,m.bufArrToArr)(t)))):t}getDataFee(){return this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork()?this.cache.dataFee.value:(Object.isFrozen(this)&&(this.cache.dataFee={value:super.getDataFee(),hardfork:this.common.hardfork()}),super.getDataFee())}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=u.from((0,Y.keccak256)(_.RLP.encode((0,m.bufArrToArr)(this.raw()))))),this.cache.hash):u.from((0,Y.keccak256)(_.RLP.encode((0,m.bufArrToArr)(this.raw()))))}getMessageToVerifySignature(){if(!this.isSigned()){const t=this._errorMsg("This transaction is not signed");throw new Error(t)}const e=this._getMessageToSign();return u.from((0,Y.keccak256)(_.RLP.encode((0,m.bufArrToArr)(e))))}getSenderPublicKey(){const e=this.getMessageToVerifySignature(),{v:t,r:o,s}=this;this._validateHighS();try{return(0,m.ecrecover)(e,t,(0,m.bigIntToUnpaddedBuffer)(o),(0,m.bigIntToUnpaddedBuffer)(s),this.supports(M.Capability.EIP155ReplayProtection)?this.common.chainId():void 0)}catch{const a=this._errorMsg("Invalid Signature");throw new Error(a)}}_processSignature(e,t,o){this.supports(M.Capability.EIP155ReplayProtection)&&(e+=this.common.chainId()*BigInt(2)+BigInt(8));const s={...this.txOptions,common:this.common};return N.fromTxData({nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,v:e,r:(0,m.bufferToBigInt)(t),s:(0,m.bufferToBigInt)(o)},s)}toJSON(){return{nonce:(0,m.bigIntToHex)(this.nonce),gasPrice:(0,m.bigIntToHex)(this.gasPrice),gasLimit:(0,m.bigIntToHex)(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:(0,m.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),v:this.v!==void 0?(0,m.bigIntToHex)(this.v):void 0,r:this.r!==void 0?(0,m.bigIntToHex)(this.r):void 0,s:this.s!==void 0?(0,m.bigIntToHex)(this.s):void 0}}_validateTxV(e,t){let o;const s=e!==void 0?Number(e):void 0;if(s!==void 0&&s<37&&s!==27&&s!==28)throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${s}`);if(s!==void 0&&s!==0&&(!t||t.gteHardfork("spuriousDragon"))&&s!==27&&s!==28)if(t){if(!Ee(BigInt(s),t.chainId()))throw new Error(`Incompatible EIP155-based V ${s} and chain id ${t.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)}else{let n;(s-35)%2===0?n=35:n=36,o=BigInt(s-n)/BigInt(2)}return this._getCommon(t,o)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}K.Transaction=N;var ne={},re={};Object.defineProperty(re,"__esModule",{value:!0});re.normalizeTxParams=void 0;const F=w,af=i=>{const e=Object.assign({},i);return e.gasLimit=(0,F.toType)(e.gasLimit??e.gas,F.TypeOutput.BigInt),e.data=e.data===void 0?e.input:e.data,e.gasPrice=e.gasPrice!==void 0?BigInt(e.gasPrice):void 0,e.value=e.value!==void 0?BigInt(e.value):void 0,e.to=e.to!==null&&e.to!==void 0?(0,F.setLengthLeft)((0,F.toBuffer)(e.to),20):null,e.v=e.v==="0x0"?"0x":e.v,e.r=e.r==="0x0"?"0x":e.r,e.s=e.s==="0x0"?"0x":e.s,e.v!=="0x"&&(e.v=(0,F.toType)(e.v,F.TypeOutput.BigInt)),e};re.normalizeTxParams=af;Object.defineProperty(ne,"__esModule",{value:!0});ne.TransactionFactory=void 0;const W=w,Te=q,ye=j,cf=re,X=K;class Q{constructor(){}static fromTxData(e,t={}){if(!("type"in e)||e.type===void 0)return X.Transaction.fromTxData(e,t);{const o=Number((0,W.bufferToBigInt)((0,W.toBuffer)(e.type)));if(o===0)return X.Transaction.fromTxData(e,t);if(o===1)return ye.AccessListEIP2930Transaction.fromTxData(e,t);if(o===2)return Te.FeeMarketEIP1559Transaction.fromTxData(e,t);throw new Error(`Tx instantiation with type ${o} not supported`)}}static fromSerializedData(e,t={}){if(e[0]<=127)switch(e[0]){case 1:return ye.AccessListEIP2930Transaction.fromSerializedTx(e,t);case 2:return Te.FeeMarketEIP1559Transaction.fromSerializedTx(e,t);default:throw new Error(`TypedTransaction with ID ${e[0]} unknown`)}else return X.Transaction.fromSerializedTx(e,t)}static fromBlockBodyData(e,t={}){if(u.isBuffer(e))return this.fromSerializedData(e,t);if(Array.isArray(e))return X.Transaction.fromValuesArray(e,t);throw new Error("Cannot decode transaction: unknown type input")}static async fromEthersProvider(e,t,o){const s=(0,W.getProvider)(e),n=await(0,W.fetchFromProvider)(s,{method:"eth_getTransactionByHash",params:[t]});if(n===null)throw new Error("No data returned from provider");return Q.fromRPCTx(n,o)}static async fromRPCTx(e,t={}){return Q.fromTxData((0,cf.normalizeTxParams)(e),t)}}ne.TransactionFactory=Q;(function(i){var e=x&&x.__createBinding||(Object.create?function(r,c,f,d){d===void 0&&(d=f);var h=Object.getOwnPropertyDescriptor(c,f);(!h||("get"in h?!c.__esModule:h.writable||h.configurable))&&(h={enumerable:!0,get:function(){return c[f]}}),Object.defineProperty(r,d,h)}:function(r,c,f,d){d===void 0&&(d=f),r[d]=c[f]}),t=x&&x.__exportStar||function(r,c){for(var f in r)f!=="default"&&!Object.prototype.hasOwnProperty.call(c,f)&&e(c,r,f)};Object.defineProperty(i,"__esModule",{value:!0}),i.TransactionFactory=i.Transaction=i.AccessListEIP2930Transaction=i.FeeMarketEIP1559Transaction=void 0;var o=q;Object.defineProperty(i,"FeeMarketEIP1559Transaction",{enumerable:!0,get:function(){return o.FeeMarketEIP1559Transaction}});var s=j;Object.defineProperty(i,"AccessListEIP2930Transaction",{enumerable:!0,get:function(){return s.AccessListEIP2930Transaction}});var n=K;Object.defineProperty(i,"Transaction",{enumerable:!0,get:function(){return n.Transaction}});var a=ne;Object.defineProperty(i,"TransactionFactory",{enumerable:!0,get:function(){return a.TransactionFactory}}),t(U,i)})(ve);const df=Ae(ve),uf=Ce({__proto__:null,default:df},[ve]);export{we as a,ve as d,uf as i};
